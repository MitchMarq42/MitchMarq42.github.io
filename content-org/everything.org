#+hugo_base_dir: ../
#+hugo_section: 

#+author: mitchmarq42

#+title: Mitchmarq42's blog etc

* Shell Scripts                                                      :@shell:
This category is for Shell-related stuff
** 1337 fake Screensaver
:PROPERTIES:
:EXPORT_FILE_NAME: trimatrix
:EXPORT_DATE: 2022-12-06
:EXPORT_HUGO_SECTION: articles/tutorials
:END:
It's 2022. Screens don't really need saving anymore - in fact, when there's talk
of a "screensaver", it's usually a lock-screen and/or just some animation that
would be cool if "screensavers" were still a thing. What I'm about to present is
no different.

*** The vision
/One Vision/
: one flesh, one bone, one true religion
: one voice, one hope, one real decision
: gimme gimme gimme gimme
: ...fried chicken

I want each of my monitors to display a fullscreen Matrix-like text crawl, and
then when I quit one of them it quits all of them. That's what I want. Should be
pretty simple, right?

*** The obvious solution
We should be able to just open one big Cmatrix window that covers all three
screens (yes I have three screens. Only two monitors though - the other one is a
laptop). That way there's only one to quit. Elementary, Watson-kun.

*** Problem 1: resolution
Here's how my monitors look physically:
: +---------------+---------------+    |   | |  +----------+
: |               |               |    pillar|  |          |
: |   1920x1080   |    1366x760   |    |   | |  | 1920x1080|
: |               |               | <--cable--> +----------+ 
: +---------------+---------------+    |___|/   \___________\

But here's how they look to the computer:
: +---------------+----------+---------------+
: |               |          |               |
: |   1920x1080   | 1366x760 |   1920x1080   |
: |               |----------|               |
: +---------------+          +---------------+

So a window that looks fine on the left monitor will be zoomed in on the middle
monitor, and small on the right +monitor+​laptop.

This means that having one big window stretching over all three screens will
look all wonky. We need separate windows with different zoom levels.
*** Problem 2: Separate windows
Opening multiple terminal windows is fine - just call them with ~&~ and call it
a day.

Closing them is another matter.

Thankfully, things like ~kill~ and ~killall~ exist. If we have the PIDs of each
terminal process, it's killable. There are various shell-scripting tricks for
getting the PID straight off the process invocation, but I decided not to bother
with anything fancy. Instead, I'll just use a terminal I don't normally --
~Xterm~ -- and kill all of those when one exits.

**** Problem 2.5: Window Placement
I'm using ubuntu on this computer because I don't care. Snaps aren't that bad,
Gnome isn't that bad, and all the server things I want to run, run. However,
Gnome is also a Wayland compositor, making ordinary Xorg tools insufficient for
automation - specifically stuff like ~xdotool~ for sending keystrokes and mouse
events. In addition, XWayland+Gnome doesn't seem to honor a window's request to
be placed on a specific monitor.

So behold! ~Ydotool~​! An Xdotool replacement for Wayland!

... which doesn't work on gnome either. At least, I couldn't get it to work. No
idea why, it's been a week since this part.

Okay, for real this time. Behold [[https://git.sr.ht/~geb/dotool][dotool]]. A display-server-agnostic desktop
automator and event simulator. Works sort of like xdotool or ydotool but with
pipe syntax for reasons.

Once it's installed and working, we can run basic commands like
#+begin_src shell
  echo "type twelve" | dotool
#+end_src
resulting in
#+RESULTS:
: twelve
getting typed to the current window.

On my gnome setup which is hacky and probably non-standard, the keybinding to
move a window to the right by one monitor is super + shift + right. Let's define
this as a function in bash:
#+begin_src shell
moveright () {
    # move a window right one workspace
    echo "key super+shift+right" | dotool
}
#+end_src
now running ~moveright~ in the terminal will move the currently selected window
to the right. It leaves the mouse in the same place because that's what the
keybinding does.

But I want to be able to move it twice. If we leave the mouse, another window
might get selected (this is a setting that I enable because it's very convenient
on tiling WMs). So another function
#+begin_src shell
mouseright () {
    # move mouse one monitor right (ish)
    echo "mousemove 1300 0" | dotool
}
#+end_src
1300 isn't quite right, but it's close enough for now.

We should also have one for moving it back to the left:
#+begin_src shell
mouseleft () {
    # move mouse one monitor left (ish)
    echo "mousemove -1300 0" | dotool
}
#+end_src

**** Problem 2.5.1: Actually throwing windows onto the screen an moving them around
Assuming we start with the mouse on the left monitor, here's the basic control
flow:
- Spawn the window that will be on the right monitor
    - Move it right (to middle monitor)
    - Move the mouse to follow it
    - Move it right (to right monitor)
- Move mouse left (back to left monitor)
- Spawn the window that will be on the middle monitor
    - Move it right (to middle monitor)
- Spawn the window that will be on the left monitor

Also, the font sizes. The rightmost screen is small but with a high resolution,
so the text should be larger. The middle screen is large with low resolution, so
small text. Then somewhere in between for the left monitor.

As previously mentioned, we're using Xterm. Xterm's (relevant) command-line
options include:
: -fullscreen                 start in fullscreen
: -bg COLOR                   background color, very intuitive
: -fa FONT                    font, semi-intuitive
: -e COMMAND                  command to run, in quotes

So to asynchronously launch a fullscreen Xterm with a black background and (not
my) Meslo font in size 12 running Cmatrix in screensaver mode, we can do:
#+begin_src shell
xterm -fullscreen -bg black -fa "MesloLGS NF:size=12" -e "cmatrix" &
#+end_src
Sprucing that up into a function taking an argument for the font size:
#+begin_src sh
  COLOR=blue
  FONT=MeseloLGS\ NF:size=
  matrixterm () {
      # spawn terminal with fun matrix in it
      # $1 = the size of font
      xterm -fullscreen -bg black -fa "${FONT}$1" -e "cmatrix -abC$COLOR" &
  }
#+end_src
Notice the expanded variable $FONT, and $COLOR. Cmatrix takes different colors
and at the moment I'm partial to blue.

So the control flow including fonts can go something like
#+begin_src shell
  openonall () {
      # Open $1 on all monitors
      $1 14
      moveright
      mouseright
      moveright
      mouseleft
      $1 9
      moveright
      $1 12
  }
  openall matrixterm
#+end_src

*** Problem 3: on opening and closing
As previously mentioned, processes are okay. If we know the PIDs we can just
kill them. [[https://www.howtogeek.com/devops/bash-process-termination-hacks/][Here's]] an article on finding and killing processes. I personally
don't believe in Xargs, so we're going to do this in multiple steps.
#+begin_src shell
XTERMS=$(ps -ef | grep xterm | grep -v 'grep' | awk '{print $2}')
#+end_src
So here's an array of all the PIDs of running ~xterm~​s. I want to streamline
checking if each of these are still running and signal an error if any aren't:
#+begin_src shell
isrunning () {
    # $1 = process to check
    ps -p $1 >/dev/null
}
checkallprocs () {
    for proc in $*
    do
	isrunning $proc || return 1
    done
}
#+end_src
So any run of ~checkallprocs $XTERMS~ will succeed as long as all of the
original xterms are running, but will fail once one is manually terminated. This
is perfect for a While loop:
#+begin_src shell
INTERVAL=0.5
while checkallprocs $XTERMS
do
    sleep $INTERVAL
done
#+end_src
The interpreter doesn't move on until this loop is broken, meaning we can simply
put the final Kill right after it.
#+begin_src shell
for proc in $XTERMS
do
    kill -9 $proc 2>/dev/null
done
#+end_src
One of those iterations will fail because that xterm is already closed. But oh
well.

*** Wrapping it up in a script with a hotkey
- [[https://git.mitchmarq42.xyz/mitch/dotfiles/src/branch/main/.local/bin/trimatrix][Here's]] the whole script

And I bound it to super+z because nothing else appeared to be bound to that key
and it's easy to hit when leaving the computer.

There's definitely improvements that can be made to this, but I found it to be a
positive learning experience and wanted to share it with thou, the void.

* Emacs stuff                                                        :@emacs:
All posts here will hopefully have category /emacs/.
** A better =cat= for Eshell
:PROPERTIES:
:EXPORT_FILE_NAME: supercat
:EXPORT_DATE: 2022-11-19
:EXPORT_HUGO_SECTION: articles/tutorials
:END:
 *tl;dr: Scroll to bottom*
*** Part 1: Awesome syntax-highlighted =cat=
A few weeks ago I was wasting time on Reddit. There was a post on r/emacs
recommending [[https://github.com/manateelazycat/aweshell][AwEshell]]. There"s several features listed, many of which I don't
particularly care about-- multiple buffers (~C-u~ works for me); IDE-style window
placement (I treat eshell like a tmux pane or terminal window). But one struck
my eye:

: 13. Make cat file with syntax highlight.

Now that's a cool idea.

Here's the function, with some minor modifications:

#+begin_src elisp
  (defun aweshell-cat-with-syntax-highlight (filename)
    "Like cat(1) but with syntax highlighting.

Taken from https://github.com/manateelazycat/aweshell/blob/d246df619573ca3f46070cc0ac82d024271ed243/aweshell.el#L775"
    (let ((existing-buffer (get-file-buffer filename))
	  (buffer (find-file-noselect filename)))
      (eshell-print
       (with-current-buffer buffer
	 (if (fboundp 'font-lock-ensure)
	     (font-lock-ensure)
	   (with-no-warnings
	     (font-lock-fontify-buffer)))
	 (let ((contents (buffer-string)))
	   (remove-text-properties 0 (length contents) '(read-only nil) contents)
	   contents)))
      (unless existing-buffer
	(kill-buffer buffer)) nil))
#+end_src

*** Part 2: To display an image
**** 
There's this Linux utility [[https://github.com/posva/catimg][catimg]] that converts images to true-color unicode
blocks and prints them to your terminal. It's nice to just view the rough image
in the terminal, without having to open another window or -- Kamisama forbid --
use the mouse.

**** 
The Kitty terminal has [[https://sw.kovidgoyal.net/kitty/kittens/icat/][a module ("Kitten")]] for displaying images. It works very
similarly to =catimg=, but uses Kitty's custom graphics protocol, and thus can
show pixel-perfect data, not just chunks.

When I'm in Kitty for any significant period of time, I tend to
#+begin_src shell
  alias catimg="kitty +icat"
#+end_src
just to remember better.

**** 
I recently signed up to Mastadon -- specifically the https://emacs.ch
instance. It's still very new, but there's a bunch of cool people on
there. Recently Xenodium (real name Álvaro Ramírez) posted a link to [[https://xenodium.com/wizard-zines-comics-eshell-util/][this blog]] in which he showcases a
custom function to view a specific image from a collection.

I thought it was odd that we don't have an =eshell/catimg= command to wrap, so I
did a little googling...

**** 
... And immediately arrived at [[https://emacs.stackexchange.com/questions/3432/display-images-in-eshell-with-iimage-mode][this StackExchange question]] about =cat=-ing files
and images with just =cat=.

The first answer is about using =iimage-mode=, which is a whole 'nother thing, and
I probably need to check it out at some point.

The second answer, the accepted one, uses Advice and a similar method to
Xenodium's to display the image. Here's the magic:
#+begin_src elisp
  (add-text-properties 0 (length arg)
                       `(display ,(create-image file)
                                 modification-hooks
                                 (iimage-modification-hook))
                       arg)
  (eshell-buffered-print arg)
#+end_src
Of course, that's in the middle of a long function that's meant to be run as
advice. I don't like Advice in principle, so I kept scrolling.

The third answer went on a tangent about inserting screenshots into Markdown
files. Which is cool, but not today.

The fourth answer should have been accepted. \\
First, there's a basic snippet for displaying images. But the answerer notes
that big images don't fit. So they provide some more thorough functions that
resize files.

For our copying convenience, here's that whole snippet but with all the functions renamed
and credited:
#+begin_src elisp
    (defun esh-catimg--imagep (filename)
      "Check if FILENAME is an image. Helper for `esh-catimg--image-print'.

  Taken from https://emacs.stackexchange.com/questions/3432/display-images-in-eshell-with-iimage-mode "
      (let ((extension (file-name-extension filename))
            (image-extensions '("png" "jpg" "bmp")))
        (member extension image-extensions)))
    (defun esh-catimg--image-width (filename)
      "Get the pixel (?) width of the image FILENAME, using imagemagick. Helper
  for `esh-catimg--image-print'.

  Taken from https://emacs.stackexchange.com/questions/3432/display-images-in-eshell-with-iimage-mode "
      (string-to-number
       (shell-command-to-string
        (format "convert '%s' -ping -format \"%%w\" info:" filename))))
    (defun esh-catimg--rescale-image (filename)
      "Rescale an image to a maximum width, or leave untouched if already small.
  Returns the new file path. Helper for `esh-catimg--image-print'.

  Taken from https://emacs.stackexchange.com/questions/3432/display-images-in-eshell-with-iimage-mode "
      (let ((file (make-temp-file "resized_emacs"))
            (max-width 350))
        (if (> (esh-catimg--image-width filename) max-width)
            (progn
              (shell-command-to-string
               (format "convert -resize %dx '%s' '%s'" max-width filename file))
              file)
          filename)))
    (defun esh-catimg--image-print (file)
      "Print the single image FILE.

  Taken from https://emacs.stackexchange.com/questions/3432/display-images-in-eshell-with-iimage-mode "
      (eshell/printnl (propertize " " 'display (create-image file))))
#+end_src

*** Putting it all together
So, to recap: We have
1. =aweshell-cat-with-syntax-highlighting= to dump any text file to eshell with syntax highlighting
2. =esh-catimg--image-print= to display any image to eshell in a reasonable size

So now it's time to put it all together. Here's =eshell/cat= with most of the guts
ripped out and replaced with our helper functions.
#+begin_src elisp
  (defun eshell/cat (&rest args)
    "Wrapper around `aweshell-cat-with-syntax-highlight' for multiple ARGS.

Also, can cat images for some reason.

See:
https://github.com/manateelazycat/aweshell/blob/d246df619573ca3f46070cc0ac82d024271ed243/aweshell.el#L775
https://emacs.stackexchange.com/questions/3432/display-images-in-eshell-with-iimage-mode "
    (setq args (eshell-stringify-list (flatten-tree args)))
    (dolist (file args)
      (if (string= file "-")
	  (throw 'eshell-external
		 (eshell-external-command "cat" args))
	(if (esh-catimg--imagep file)
	    (esh-catimg--image-print (esh-catimg--rescale-image file))
	  (aweshell-cat-with-syntax-highlight file)))))
#+end_src
It iterates over each argument and applies the correct function.


** Making Neofetch aware of Emacs :@shell:
:PROPERTIES:
:EXPORT_FILE_NAME: eofetch
:EXPORT_DATE: 2022-12-02
:EXPORT_HUGO_SECTION: articles/tutorials
:END:
*** Introduction
I have a confession to make. I was, and still technically am, an Arch user (by
the way). On my main machines I use ubuntu or fedora, but that's only because
I'm tired of updates and reboots. Computers have always been toys to me, but the
OS itself was becoming more of a tool or platform.

Enter Emacs.

If you're reading this, you probably know how freakin' /cool/ Emacs is. A few days
ago, the [[https://codeberg.org/akib/emacs-eat][EAT terminal]] went public, and it's great. You can even use it inside
Eshell. And with this, it feels like Emacs is my true OS more than the
underlying OS itself, I felt it would be a good exercise to have blingy terminal
tools reflect that.

Enter Neofetch.

If you somehow haven't come across Neofetch yet, Kamisama bless your sweet
summer soul. It's the thing that looks like this:

{{< figure
src=https://linoxide.com/wp-content/uploads/2018/07/neofetch-ArchLinux.png >}}

The challenge: *Make Neofetch display the Emacs logo*

*** Part 1: how Neofetch works
Neofetch is written in Bash 3.2+, which makes it compatible with even the
ancient bash that MacOS ships with. It has a config file which it creates if not
present, and will read from at startup. This config file is also written in
Bash, and thus you can define custom functions in it that follow the standard
format of the built-in ones. For example:
#+begin_src bash
get_pane() {
    pane=$(
        [ -n ${TMUX} ] &&
            echo "${TMUX//%//}"
        [ -z ${TMUX} ] &&
            echo 'N/A'
    )
prin "Tmux Pane" "$pane"
}
#+end_src
This displays the Tmux pane that you're in, or else "N/A". I used to use tmux
for everything because I wanted to keep processes running despite closing and
opening terminals, and splitting windows arbitrarily. Thankfully now Emacs can
handle most of that!

Anyway, snippets like the above will get recognized by neofetch when it prints
information on the right of the image. It scans for all the "get_*" functions
and runs them in the order described in the function ~print_info~ (defined at the
top of the config). So for tmux all I have to do to enable it is put something
like
#+begin_src bash
    info "Tmux Pane" pane
#+end_src
before the end of that function.

Problem:
**** Logos do not work like info lines
All of the ascii art that Neofetch displays happens through a single function
called ~get_distro_ascii~ which consists of a single *5226*-line Case statement,
each of which contains a color setting and a mangled-looking heredoc to dump to
the terminal.

This is not extensible at all.

The standard advice is to submit a pull request and add the distro/image you
want, but the maintainer seems to no longer be active. There are forks, but I
really don't want to rely on that kind of thing. As long as the original
Neofetch works, I will use it and only modify my own config file. It's just
simpler that way.

So now, we have a puzzle: How do we +advise+ add to a function in Bash without
wiping out the original?

*** Part 2: Adding to a function in Bash
If this were Elisp, I would just do something like
#+begin_src elisp
(setq old-get_distro_ascii (symbol-function 'get_distro_ascii))
(defun get_distro_ascii ()
  (if (<test-are-we-in-emacs>)
      (<display-emacs-things>)
    (funcall old-get_distro_ascii)))
#+end_src

I /really/ didn't want to bother figuring this out in bash. So I did a web
search. And what I discovered, may shock you.

[[https://www.appsloveworld.com/bash/100/210/save-the-old-value-of-a-function-bash-so-that-it-can-be-called-later][Renaming a function]] is totally a thing!

So all I would have to do in Bash is
#+begin_src bash
  renameFunction get_distro_ascii old--get_distro_ascii
  get_distro_ascii ()
  if <check-if-emacs>; then
      <display-emacs-things>
  else
      old--get_distro_ascii
  fi
#+end_src

Now with the technical aspect out of the way, time to do Art.
*** Part 3: Art
There's this really handy site
https://www.text-image.com/convert/ascii.html. You give it an image and a pixel
width, and it spits out ascii art of the image. Good start.

: @@@@@@@@@@@@@@@@@&&&&&&@@@@@@@@@@@@@@@@@
: @@@@@@@@@@@&#GPYYJJJJJJY5PB#&@@@@@@@@@@@
: @@@@@@@@&GYJ????????J?????JJYPB&@@@@@@@@
: @@@@@@#5J?????????7!^:..  .7JJJYG&@@@@@@
: @@@@&PJ????J?????7!!~~^.    JYYYY5B@@@@@
: @@@&5??????^.           ...!YYYYYYYG&@@@
: @@&5??????J^    .!7?JJJYYYYYYYYYYYYYG@@@
: @@G????JJJJJ?^.  .~7JYYYYYYYYYYY55555#@@
: @&5?JJJJJJJYYYY?~.   .:!?YYYY55555555G@@
: @&Y?JJJJJY?!^..       .:~?55555555555G&@
: @&5JJJJJ7.      .^!?JY555555555555555B@@
: @@GJJJY?      :Y555555555555555555555#@@
: @@&5JYYY~     .~7?JJYYYYY5555P555555B@@@
: @@@&PJYYYY?~:.         .    .:JP555B&@@@
: @@@@&GYYYY5555YYJ?7!~^:.   .^7555P#@@@@@
: @@@@@@&G5YY555Y?7!!~~!7?JY5PPP5PB&@@@@@@
: @@@@@@@@&BP555555555PPPP5555PG#&@@@@@@@@
: @@@@@@@@@@@&#BGGPPPPPPPPGB#&@@@@@@@@@@@@
: @@@@@@@@@@@@@@@@@@&&&&@@@@@@@@@@@@@@@@@@

(the above is the Emacs logo at
https://www.gnu.org/software/emacs/images/emacs.png with a width of 40.)

This is nice, but there's two problems:
1. ~@~ Background
2. Monochrome

Let's tackle the ~@~ background first:

:                  &&&&&&
:            &#GPYYJJJJJJY5PB#&
:         &GYJ????????J?????JJYPB&
:       #5J?????????7!*./eEe.7JJJYG&
:     &PJ????J?????7!!~~^/eeeeJYYYY5B
:    &5??????^.eeeeeeeeeee/^/!YYYYYYYG&
:   &5??????J^eeee.!7?JJJYYYYYYYYYYYYYG
:   G????JJJJJ?^\ee\~7JYYYYYYYYYYY55555#
:  &5?JJJJJJJYYYY?~\eee.:!?YYYY55555555G
:  &Y?JJJJJY?!^./eeeeeee.:~?55555555555G&
:  &5JJJJJ7.eeeeee/^!?JY555555555555555B
:   GJJJY?eeeeee:Y555555555555555555555#
:   &5JYYY~eeeee\.7?JJYYYYY5555P555555B
:    &PJYYYY?~:\eeeeeeeeeEeee\.:JP555B&
:     &GYYYY5555YYJ?7!~\.>eee/^7555P#
:       &G5YY555Y?7!.~~^7?JY5PPP5PB&
:         &BP555555555PPPP5555PG#&
:            &#BGGPPPPPPPPGB#&
:                   &&&&

The ~@~​s were pretty easy to get rid of. I used a /lot/ of evil-Ex commands. Also,
you may notice that the giant E has been filled in with little ~e~​s.

Next, the coloring.

**** How Neofetch works part 2: the coloring
Each clause in that giant Case statement has a ~set-colors x y~ line above the art
itself. ~x~ and ~y~ (and posssibly more) are simply the 8/16 terminal colors.
: 0. Black
: 1. Red
: 2. Green
: 
: etc.

Color 5 is magenta and color 7 is white. If we allow the "dark/light" colors
(8-15) we should probably use 13 (darkmagenta) and 15 (darkwhite), but I don't
particularly want to rely on that, and my theme's colors may be backwards so
we'll stick to 5 and 7 for now.

Neofetch embeds color escape codes in the ascii art with sequences like ~${cX}~
where X is the slot after ~set-colors~. Thus we can ~set-colors 5 7~ and then access
color 5 with ~${c1}~ and color 7 with ~${c2}~.

Let's can put ~${c1}~ right before the start of the art. Then when the white E
would start we put a ~${c2}~, and when each line of the E ends another ~${c1}~. This
looks gross:

: ${c1}                &&&&&&
: 	  &#GPYYJJJJJJY5PB#&
:        &GYJ????????J?????JJYPB&
:      #5J?????????7!*${c2}./eEe${c1}.7JJJYG&
:    &PJ????J?????7!!~~^${c2}/eeee${c1}JYYYY5B
:   &5??????^${c2}.eeeeeeeeeee/^${c1}/!YYYYYYYG&
:  &5??????J^${c2}eeee.${c1}!7?JJJYYYYYYYYYYYYYG
:  G????JJJJJ?^${c2}\\ee\${c1}~7JYYYYYYYYYYY55555#
: &5?JJJJJJJYYYY?~${c2}\\eee.${c1}:!?YYYY55555555G
: &Y?JJJJJY?!^${c2}./eeeeeee.${c1}:~?55555555555G&
: &5JJJJJ7${c2}.eeeeee/${c1}^!?JY555555555555555B
:  GJJJY?${c2}eeeeee${c1}:Y555555555555555555555#
:  &5JYYY~${c2}eeeee\.${c1}7?JJYYYYY5555P555555B
:   &PJYYYY?~:${c2}\\eeeeeeeeeEeee\.${c1}:JP555B&
:    &GYYYY5555YYJ?7!~\${c2}.>eee/${c1}^7555P#
:      &G5YY555Y?7!${c2}.~~^${c1}7?JY5PPP5PB&
:        &BP555555555PPPP5555PG#&
: 	  &#BGGPPPPPPPPGB#&
: 		 &&&&

But the screenshot doesn't:

https://mitchmarq42.xyz/eofetch.png

*** Part 4: Putting it all together
Problem: How do we tell neofetch that it's inside Emacs? Well, there is the
variable ~$INSIDE_EMACS~​. The problem is how and where to use it.

I actually didn't have a perfect solution when I tooted out that screenshot. Nor
when I started this article. But I've done a minor hack and now have a solution.

In the default config file there's a line: ~ascii_distro="auto"~​. Neofetch by
default auto-detects your distro from various things like ~uname~ and 
​/​etc​/​issue. It overrides this if you pass the command-line option
~--ascii-distro~​. This all happens /before/ ~get_distro_ascii~ is run. Which of
course, but that also means we can't detect whether there was a command-line
override within our new ~get_distro_ascii~​.

Looking at it with fresh eyes, we can clearly just check when ~ascii_distro~ would
get set to auto. So first replace
#+begin_src bash
  ascii_distro="auto"
#+end_src
with
#+begin_src bash
  ascii_distro=$(
      if [[ $INSIDE_EMACS ]]; then
          echo "Emacs"
      else
          echo "auto"
      fi
              )
#+end_src
Then, below the initial ~print_info()~ definition but above everything else, paste
the code from [[https://www.appsloveworld.com/bash/100/210/save-the-old-value-of-a-function-bash-so-that-it-can-be-called-later][that article]] to rename bash functions. Then use it:
#+begin_src bash
  renameFunction get_distro_ascii old--get_distro_ascii
#+end_src
And now we can *finally* get to the good bit. I'm using a case statement just like
the original, since we're setting ~$ascii_distro~ beforehand.
#+begin_src bash
  get_distro_ascii() {
      case $(trim "$ascii_distro") in
          "Emacs")
              # set_colors 13 15
              set_colors 5 7
              read -rd '' ascii_data <<'EOF'
  ${c1}                &&&&&&
            &#GPYYJJJJJJY5PB#&
         &GYJ????????J?????JJYPB&
       #5J?????????7!*${c2}./eEe${c1}.7JJJYG&
     &PJ????J?????7!!~~^${c2}/eeee${c1}JYYYY5B
    &5??????^${c2}.eeeeeeeeeee/^${c1}/!YYYYYYYG&
   &5??????J^${c2}eeee.${c1}!7?JJJYYYYYYYYYYYYYG
   G????JJJJJ?^${c2}\\ee\${c1}~7JYYYYYYYYYYY55555#
  &5?JJJJJJJYYYY?~${c2}\\eee.${c1}:!?YYYY55555555G
  &Y?JJJJJY?!^${c2}./eeeeeee.${c1}:~?55555555555G&
  &5JJJJJ7${c2}.eeeeee/${c1}^!?JY555555555555555B
   GJJJY?${c2}eeeeee${c1}:Y555555555555555555555#
   &5JYYY~${c2}eeeee\.${c1}7?JJYYYYY5555P555555B
    &PJYYYY?~:${c2}\\eeeeeeeeeEeee\.${c1}:JP555B&
     &GYYYY5555YYJ?7!~\${c2}.>eee/${c1}^7555P#
       &G5YY555Y?7!${c2}.~~^${c1}7?JY5PPP5PB&
         &BP555555555PPPP5555PG#&
            &#BGGPPPPPPPPGB#&
                   &&&&
  EOF
              ;;
          ,*)
              # if not in emacs just run the original which displays your distro
              old--get_distro_ascii
      esac
  }
#+end_src

Now running ~neofetch~ inside any Emacs terminal (again, I recommend Akib's
[[https://codeberg.org/akib/emacs-eat][EAT]]+Eshell), or with the variable ~$INSIDE_EMACS~ set, will display the custom
Emacs logo. Running neofetch outside of Emacs should still display your distro's
logo, and running it _inside_ Emacs but with ~--ascii_distro arch~ will display the
Arch logo.

*ADDENDUM:* If you're on Mac you might have to put ~old_get_distro_ascii~
 instead of ~old--get_distro_ascii~, as their ancient Bash gives an error about
 invalid identifier. 

